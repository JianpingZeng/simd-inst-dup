/*
 * Author: Zhi Chen zhic2@uci.edu
 */

#define DEBUG_TYPE "APPROX"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/CommandLine.h" //command line options
#include "llvm/ADT/Statistic.h"
#include "llvm/ADT/APInt.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/Support/InstIterator.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
#include "llvm/IR/IRBuilder.h"
#include <llvm/IR/Module.h>
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Constant.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/CFG.h"
#include "approximate.hxx"
#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>

using namespace llvm;

cl::opt<bool> APVerbose("ap-verbose",
                        cl::desc("verbose"),
                        cl::init(false));
cl::opt<bool> APUseProfile("use-profile",
                        cl::desc("verbose"),
                        cl::init(true));
cl::opt<bool> APExitBB("ap-insert-BB",
                            cl::desc("Insert exit BB for transfer of control"),
                            cl::init(true));
cl::opt<bool> APValues("ap-values",
                            cl::desc("Insert checks on values"),
                            cl::init(true));
cl::opt<bool> APDuplication("ap-dup",
                            cl::desc("Insert duplication for state variables"),
                            cl::init(true));
cl::opt<bool> APNop("ap-nop",
                            cl::desc("Insert nop intrinsic"),
                            cl::init(true));
cl::opt<bool> APVPCounter("ap-vp-counter",
                            cl::desc("Insert counter instead of a function call"),
                            cl::init(false));
cl::opt<bool> APExcludeInfreq("ap-exclude-infrequent",
                            cl::desc("Exclude infrequently executed"),
                            cl::init(false));

cl::opt<bool> APDebug("ap-debug",
                            cl::desc("Do the debug stuff"),
                            cl::init(false));
cl::opt<bool> localStatsAP("ap-localstats",
                            cl::desc("print the statistic collected"),
                            cl::init(false));
cl::opt<bool> scalarToVec("scalar-vector-convert",
                            cl::desc("duplicate scalr instructions and generate the corresponding vector instruction"),
                            cl::init(true));

static cl::opt<std::string>
ProfileInfoFilename2("profile-info-file2", cl::init("llvmprof.out"),
                    cl::value_desc("filename"),
                    cl::desc("Profile file loaded by -profile-loader2"));
STATISTIC(counter, "The number of functions greeted");
STATISTIC(totalIR, "The number of total IR instructions");
STATISTIC(duplicatedIR, "The number of dupliacted IR instructions");
//STATISTIC(expChecks, "The number of total expected value checks inserted");

char Approx::ID = 0;
//unsigned long long Approx::totStateVars = 0;
//unsigned long long Approx::totStateVarsDyn = 0;
//unsigned long long Approx::totalIRDyn = 0;
//unsigned long long Approx::stateVarsDyn = 0;
//unsigned long long Approx::duplicatedIRDyn = 0;
//unsigned long long Approx::expChecksDyn = 0;
unsigned long long Approx::totFPVars = 0;
//unsigned long long Approx::totFPVarsDyn = 0;
//unsigned long long Approx::totErrors = 0;
unsigned long long Approx::totFPVecInst = 0;
bool Approx::flag = false;
GlobalVariable* Approx::vpGlobal = NULL;

Value* Approx::exitStr = NULL;

bool Approx::doFinalization(Module &M){
  if(localStatsAP){
//    errs() << totalIRDyn << " The number of total dynamic IR instructions" << "\n"; 
//    errs() << stateVarsDyn << " The number of total dynamic state variables" << "\n"; 
//    errs() << duplicatedIRDyn << " The number of dupliacted dynamic IR instructions" << "\n"; 
//    errs() << expChecksDyn << " The number of total expected value dynamic instructions inserted" << "\n";
    errs() << "----------------------------------" << "\n";
  }
  return true;
}

static RegisterPass<Approx> X("approx", "Insert checking for values");
void Approx::getAnalysisUsage(AnalysisUsage &AU) const{
  AU.addRequired<LoopInfo>();
  if(APUseProfile){
   // AU.addRequired<ProfileInfo>();
   // AU.addRequired<LoaderPassB>();
    //AU.addRequired<MyProfileInfo>();
  }
  AU.addRequired<DataLayout>();
}

bool Approx::runOnFunction(Function &F){
  errs() << "Analyzing function: " << F.getName().str() << "\n"; 
  TD = &getAnalysis<DataLayout>();
  ++counter;
  currF = &F;
  for(tInstrToInfoObj::iterator iter = instrToInfoObj.begin(); iter != instrToInfoObj.end(); iter++){
    delete ((*iter).second);
  }
  instrToInfoObj.clear();
  vcmpToCheckInst.clear();
  cmpInstInserted.clear();
  vcmpInstInserted.clear();
  valueCheckSet.clear();
  valueRangeCheckSet.clear();
  ptrCheckSet.clear();
  alreadySeen.clear();
  scalarToVectorMap.clear();
  instrVec.clear();
  tobeFixedPhiNodes.clear();
  extractedInst.clear();

  LI = &getAnalysis<LoopInfo>();

  for(inst_iterator I = inst_begin(F), E = inst_end(F); I != E; ++I){
    Instruction *pInst = &*I;
    //errs() << "Instruction is " << *pInst << "\n";
    //getFrequentRange(VP->InstToIdMap[pInst]);
    //exit(1);
    instrInfo* infoObj = new instrInfo(pInst);
    instrToInfoObj[pInst] = infoObj;
    instrVec.push_back(pInst);

// ------------------- added by zhi for f.p. instruction duplication ---------------------
// isVectorTy should be handled differently because there are two possible solutions for it.
// 1. duplicate the whole instruction for vectorized instructions because there is no free slot in a SSE/AVX register
// 2. broadcast the high 128/64 bits to the low 128/64 bits depending on AVX/SSE. In this case the original instruction
//    and the duplicated instructions are packed in the same register. 
// We have a setFPVarVector method to check vector instructions. 
//  if ((pInst->getType())->isFPOrFPVectorTy() || 
//      pInst->getOpcode() == Instruction::Store ||
//      pInst->getOpcode() == Instruction::FCmp) {// || (pInst->getType())->isVectorTy()) {
	  if ((pInst->getType())->isVectorTy() && pInst->getOpcode() != Instruction::InsertElement) {
	    //errs()<< *pInst << " is a vector instruction."<<"\n";	
        instrToInfoObj[pInst]->setFPVectorInst();
        totFPVecInst++;
	  }
	  instrToInfoObj[pInst]->setFPVar();
	  totFPVars++;
//  }
    totalIR++;
  }

  errs() << "\nInstruction scanning is done! Now performing instruction duplication......" << "\n\n";

  if(APDuplication){
    duplicateProducers();
  }
  
  errs() << "\nInstruction duplication is done! Now fixing the phi nodes and cleaning the instrumented scalar instructions....." << "\n\n";

  fixHolesInPhiNodes();
  
  if (scalarToVec) {
    deleteInstrumentedScalarInst();
  }

  errs() << "\nInstruction cleaning is done! Now splitting the basic blocks according to the inserted error checking code...." << "\n\n";

  if(APVPCounter){
    createGlobal(); 
  }
  //split at inserted cmps and point to exit block
  //createExitBB();
  //splitBBAndPointExitBlock();

  errs() << "\nInstrumenation for Function " << F.getName().str() << " is done! You can generate code with LLC\n\n";

  flag = true;
  return true;
}

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupProducers"
int Approx::duplicateProducers(){
  int longestPath = 0;
//  DEBUG(dbgs() << "*** Duplicating producers of state variables in function " <<  currF->getName() << " ***" << "\n");
  DEBUG(dbgs() << "*** Duplicating producers of FP variables in function " <<  currF->getName() << " ***" << "\n");
  int SV_chain = 0;
  std::stringstream scalarDupName("S");
  std::stringstream vectorDupName("V");
  Instruction *dupInst = NULL;
  //for(std::map<Instruction*, instrInfo*>::iterator iter = instrToInfoObj.begin(); iter != instrToInfoObj.end(); iter++) { 
  for (std::vector<Instruction*>::iterator it = instrVec.begin(); it != instrVec.end(); it++) {
    instrInfo *currInstInfo = instrToInfoObj[*it];
  //  if (currInstInfo->isFPVar() && scalarToVectorMap.find(*it) == scalarToVectorMap.end()){
    if (scalarToVectorMap.find(*it) == scalarToVectorMap.end()){
      Instruction *currInst = *it;
      if (handledByValue(currInst)) {
         DEBUG(dbgs() << "Handled by value (exact or range)" << "\n");
      }
      else {
        DEBUG(dbgs() << "Current FP instr " << *currInst << "\n");
        std::stringstream chainName;
        std::stringstream checkingName;
        if(currInstInfo->isFPVectorInst()){       // if the current instruction is already vectorized, we can only do scalar duplication
          chainName << vectorDupName.str() << SV_chain << "_D";
          checkingName<< "EDCS" << checkingName ;

          dupInst = duplicateProdRec(currInst, chainName.str());
          if (dupInst != NULL) {
            DEBUG(dbgs() << "Duplicated FP instr " << *dupInst << "\n");
            //error checking
       	    //insertCmp(currInst, dupInst, currInst, checkingName.str(), true);
          }
        }
        else {
          //chainName << vectorDupName.str() << ((dyn_cast<Value> (currInst))->getName()).str();
          chainName << scalarDupName.str() << SV_chain << "_D";
          checkingName << "EDCV" << checkingName;
          Instruction *vectorizedInst = duplicateScalarToVector(currInst, chainName.str()); 
            
          //error checking  
         /* if(vectorizedInst != NULL) {  // the current inst is arithmetic and convert
            if (currInst->getOpcode() != Instruction::BitCast || 
               (currInst->getOpcode() == Instruction::BitCast &&
                vectorizableBitcast(currInst)))
              dupInst = createShuffleInst(vectorizedInst, chainName.str());
            else {  //double check here
                dupInst = vectorizedInst;
                vectorizedInst = currInst;
            }
            insertCmp(dupInst, dupInst, vectorizedInst, checkingName.str(), true);
          }*/
        }
        SV_chain++;
      }
    }
  }
  return longestPath;
}

bool Approx::vectorizableBitcast(const Instruction *pInst) {
    Value *oprand = pInst->getOperand(0);
    if (oprand->getType()->isVectorTy() || pInst->getType()->isVectorTy())
      return false;
    return true;
}

Instruction* Approx::createShuffleInst(Instruction *pInst, const std::string& instName) {
  Instruction *dupInst = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);
  errs() << *pInst << "\n" << *insertAt << "\n";
  Type* u32Ty = Type::getInt32Ty(currF->getContext());
  Value *Val = dyn_cast<Value> (pInst);

  SmallVector<Constant*, 8> MaskVec(VEC_LENGTH);
  MaskVec[0] = ConstantInt::get(u32Ty, 0); MaskVec[1] = ConstantInt::get(u32Ty, 1);
  Value *mask = ConstantVector::get(MaskVec);
  Value *shuffleVal = builder.CreateShuffleVector(Val, Val, mask, "SF"+instName);
  dupInst  = dyn_cast<Instruction> (shuffleVal);

  //dupInst = pInst;
  errs() << "the shuffled instruction is: " << *dupInst << "\n";
  return dupInst;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupScalarToVector"
//duplicate the scalar instruction to vector mode
Instruction* Approx::duplicateScalarToVector(Instruction *pInst, const std::string &instName) { 
  Instruction *duplicatedInst = NULL;
  if (scalarToVectorMap.find(pInst) != scalarToVectorMap.end()) {
    duplicatedInst = scalarToVectorMap[pInst]->replacedBy();
  }
  else {
    switch(pInst->getOpcode()) {
      //memory instructions
      case Instruction::GetElementPtr:
        duplicateScalarGEP1(pInst, instName);
        break;
      case Instruction::Load:
        duplicateScalarLoad(pInst, instName); 
        break;
      case Instruction::Store:
        duplicateScalarStore(pInst, instName);
        break;
      case Instruction::Alloca:
        break;
      case Instruction::Ret:
        instrumentReturn(pInst, instName);
        break;
      case Instruction::Switch:
        break;
      case Instruction::Br:
        duplicateBranch(pInst, instName);
        break;
      case Instruction::ExtractElement:
        duplicateExtractElement(pInst, instName);
        break;
      case Instruction::InsertElement:
        duplicateInsertElement(pInst, instName);
        break;
      case Instruction::PHI:
        //duplicatedInst = duplicatePhiNode(pInst, instName);
        duplicatePhiNodeVectorTy(pInst, instName);
        break;
      case Instruction::Select:
        duplicateSelect(pInst, instName);
        break;
      
      //standard arithmetic operations and comparisons
      case Instruction::FCmp: 
      case Instruction::ICmp: 
      case Instruction::FAdd: 
      case Instruction::Add:
      case Instruction::FSub:
      case Instruction::Sub:
      case Instruction::FMul:
      case Instruction::Mul:
      case Instruction::FDiv:
      case Instruction::UDiv:
      case Instruction::SDiv:
      case Instruction::FRem:
      case Instruction::URem:
      case Instruction::SRem:
      case Instruction::Shl:
      case Instruction::LShr:
      case Instruction::AShr:
      case Instruction::And:
      case Instruction::Or:
      case Instruction::Xor:
        duplicatedInst = duplicateScalarArithmetic(pInst, instName);
        break;
      case Instruction::Call: {
        CallInst *call = dyn_cast<CallInst> (pInst);
        Type *retTy = call->getType();
        Function *func = call->getCalledFunction();
        std::string funName = "vcall"; // = func->getName().str();
        if (func != NULL) {
          funName = func->getName().str();
        }

        //errs() << "Return type of " << funName << " is: " << *retTy << "\n";

        if (funName == "sqrt" || funName == "fabs" || funName == "sin" ||
            funName == "cos" || funName == "exp" || funName == "log" || 
            funName == "log10" || funName == "log2" || funName == "floor" ||
            funName == "ceil" || funName == "trunc" || funName == "rint" ||
            funName == "round" || funName == "exp2")
          duplicatedInst = duplicateScalarArithmetic(pInst, instName, 1);    //mainly for sqrt, sin, cos....
        else if (funName == "maxnum" || funName == "minnum" || funName == "pow" || funName == "powi")
          duplicatedInst = duplicateScalarArithmetic(pInst, instName, 2);    //for functions with 2 parameters
        else if (funName == "fma")
          duplicatedInst = duplicateScalarArithmetic(pInst, instName, 3);    //for functions with 3 parameters
        else if (retTy->isFloatingPointTy() || retTy->isIntegerTy() || retTy->isPointerTy())
          duplicatedInst = duplicateCall(pInst, instName);
        break;
      }

      //convert instruction:
      case Instruction::FPTrunc:
      case Instruction::Trunc:
      case Instruction::FPExt:
      case Instruction::ZExt:
      case Instruction::SExt:
        duplicatedInst = duplicateFPTruncExt(pInst, instName);
        break;
      case Instruction::SIToFP:
      case Instruction::FPToSI:
      case Instruction::UIToFP:
      case Instruction::FPToUI:
      case Instruction::IntToPtr:
      case Instruction::PtrToInt:
      //case Instruction::AddrSpaceCast:
        duplicatedInst = duplicateTypeConvert(pInst, instName);
        break;
      case Instruction::BitCast: {      
      //FIXME. is <2 x doubl>* a vectorTy or pointerTy? No matter what it is, don't duplicate it
        Value *oprand = pInst->getOperand(0);
        if (oprand->getType()->isVectorTy() || pInst->getType()->isVectorTy()) {
            duplicatedInst = duplicateBitcast(pInst, instName);
        }
        else {
          duplicatedInst = duplicateScalarArithmetic(pInst, instName); 
        }
        break;
      }
      default:
        break;
    }
  }
  return duplicatedInst;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupScalarMemory"
//just create a vector for Alloca instruction
Instruction *Approx::duplicateScalarAlloca(Instruction* pInst, const std::string &instName) {
  Instruction *vAlloca = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<>builder(&*insertAt);
  Value *vAllocaVal = dyn_cast<Value> (pInst);
  Value *scalarToVector = builder.CreateVectorSplat(VEC_LENGTH, vAllocaVal, "splat"+instName);
  vAlloca = dyn_cast<Instruction> (scalarToVector);

  instrInfo *pInstInfo = new instrInfo(vAlloca);
  pInstInfo->setReplacedBy(vAlloca);
  scalarToVectorMap[pInst] = pInstInfo;
  
  errs() <<"vectorized Alloca instruction: "<< *vAlloca << "\n";
  return vAlloca;
}
//if a field in GEP instruction is instrumented before, extract it
Instruction *Approx::duplicateScalarGEP(Instruction* pInst, const std::string &instName) {
  Instruction *vGepInst = NULL;
  Value *gepValue;

  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  Instruction *newGEP = pInst->clone();
  newGEP->setName(instName);
  newGEP->insertBefore(insertAt);
  bool needNewGEP = false;
  insertAt = newGEP;
  IRBuilder<> builder(&*insertAt);
  Type* u32Ty = Type::getInt32Ty(currF->getContext());
  Value *index =  ConstantInt::get(u32Ty, 1);
  unsigned i = 0;

  for(User::op_iterator it =  pInst->op_begin(), it_e = pInst->op_end(); it != it_e; ++it, ++i){
    Value* usedVal = *it;
    Instruction *curInst = dyn_cast<Instruction> (usedVal);
    if (curInst && scalarToVectorMap.find(curInst) != scalarToVectorMap.end()) { 
      needNewGEP = true;
      Instruction *vecOp = scalarToVectorMap[curInst]->replacedBy();
      Value *extVal = builder.CreateExtractElement(vecOp, index, "extract"+instName);
      newGEP->setOperand(i, extVal);
    }
    else {
        needNewGEP = false;
        break;
    }
  }
 
  if (!needNewGEP) {
    gepValue = dyn_cast<Value> (pInst);
  }
  else {
    gepValue = dyn_cast<Value> (newGEP);
  } 

  insertAt++;
  Value *scalarToVector = builder.CreateVectorSplat(VEC_LENGTH, gepValue, "splat"+instName);
    //errs() << *scalarToVector << "   " << scalarToVector->getType() << "\n";
  vGepInst = dyn_cast<Instruction> (scalarToVector);
   
  if (!needNewGEP) 
    newGEP->eraseFromParent(); 
  instrInfo *pInstInfo = new instrInfo(vGepInst);
  pInstInfo->setReplacedBy(vGepInst);
  scalarToVectorMap[pInst] = pInstInfo;
  errs() <<"vectorized GEP instruction: "<< *vGepInst << "\n";
 
  return vGepInst;
}

Instruction *Approx::duplicateScalarGEP1(Instruction* &pInst, const std::string &instName) {
  Instruction *vGepInst = NULL;

  IRBuilder<> builder(&*pInst);
  unsigned i = 0;

  Type* u32Ty = Type::getInt32Ty(currF->getContext());
  Value *index =  ConstantInt::get(u32Ty, 1);
  for(User::op_iterator it =  pInst->op_begin(), it_e = pInst->op_end(); it != it_e; ++it, ++i){
    Value* usedVal = *it;
    Instruction *curInst = dyn_cast<Instruction> (usedVal);
    if (curInst && scalarToVectorMap.find(curInst) != scalarToVectorMap.end()) { 
      Instruction *vecOp = scalarToVectorMap[curInst]->replacedBy();
      Value *extVal = builder.CreateExtractElement(vecOp, index, "extract"+instName);
      pInst->setOperand(i, extVal);
    }
  }
 
  errs() <<"vectorized GEP1 instruction: "<< *pInst << "\n";
  return vGepInst;
}

Instruction *Approx::duplicateExtractElement(Instruction *pInst, const std::string &instName) {
  Instruction *vExtract = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);
  Value *extractVal = dyn_cast<Value> (pInst);

  Value *vExtVal = builder.CreateVectorSplat(VEC_LENGTH, extractVal, "splat"+instName);
  vExtract = dyn_cast<Instruction> (vExtVal);
  instrInfo *pInstInfo = new instrInfo(vExtract);
  pInstInfo->setReplacedBy(vExtract);
  scalarToVectorMap[pInst] = pInstInfo;

  errs() << "vectorized extractelement: " << *vExtract << "\n";    
  return vExtract;
}

//<result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx>    ; yields <n x <ty>>
//if we have the following insertelement instructions:
//%49 = insertelement <2 x double> undef, double %div, i32 0
//%50 = insertelement <2 x double> %49, double %div, i32 1
//check if %div in %49 is already defined, actually it has to
//if it is, then change %50 = vectorized %div and remove %49
//return NULL for insertelement because they are either removed or not duplicated
Instruction *Approx::duplicateInsertElement(Instruction *&pInst, const std::string &instName) {
  Instruction *vInsElem = NULL;

  int count = VEC_LENGTH;
  BasicBlock::iterator tmp = pInst;
  for (; count > 0 && tmp; --count, --tmp) {
    if (tmp->getOpcode() != Instruction::InsertElement) 
      break;
  }

  //if the number of insertelement instructions is less than VEC_LENGTH, don't do anything
  if (count != 0)
      return NULL;

  Value *operand = pInst->getOperand(1);       //get the vector value
  Instruction *vecOpInst = dyn_cast<Instruction> (operand);

  if (scalarToVectorMap.find(vecOpInst) != scalarToVectorMap.end()) {
    //tmp = pInst;
    //tmp--;
    //for (count = VEC_LENGTH-1; count > 0 && tmp; --count, --tmp) {
    //  errs() << "remove insert element: " << *tmp << "\n";
    //}
    //how to change pInst????????????????
    Instruction *replacedBy = scalarToVectorMap[vecOpInst]->replacedBy(); 
    pInst->replaceAllUsesWith(dyn_cast<Value>(replacedBy));
    instrInfo *pInstInfo = new instrInfo(replacedBy);
    pInstInfo->setReplacedBy(replacedBy);
    scalarToVectorMap[pInst] = pInstInfo;
 }
  return vInsElem;
}
Instruction *Approx::instrumentReturn(Instruction *&pInst, const std::string &instName) {
  ReturnInst *retInst = dyn_cast<ReturnInst> (pInst);
  Value *retVal = retInst->getReturnValue();
  if (retVal == NULL) {
    return NULL;
  }

  if (retVal->getType()->isVoidTy()) {
    return NULL;
  }

  Instruction *newRet = NULL;
  IRBuilder<> builder(&*pInst);

  if (dyn_cast<Constant> (retVal)) {
    return NULL;
  }
  Instruction *ret = dyn_cast<Instruction> (retVal);

  if (scalarToVectorMap.find(ret) != scalarToVectorMap.end()) {
    Type* u32Ty = Type::getInt32Ty(currF->getContext());
    Value *index =  ConstantInt::get(u32Ty, 1);
    Instruction *vecOp = scalarToVectorMap[ret]->replacedBy();
    Value *newRetVal = builder.CreateExtractElement(vecOp, index, "extract"+instName);
    pInst->setOperand(0, newRetVal);
  } 
  return newRet; 
}
//vector the scalar load instruction
//the following method load two consecutive elements (_mm_load_pd). That not what we want
//we want _mm_load1_pd
/*Instruction *Approx::duplicateScalarLoad(Instruction* pInst, const std::string &instName) {
  Value *loadAddr = pInst->getOperand(1);
  //Instruction *operand = dyn_cast<Instruction>(loadValue);
  LoadInst *vectorizedLDInstr = NULL;
  VectorType *vecTy = NULL;
  Type *lvTy = loadValue->getType();
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);
 
  Value *scalarToVector = builder.CreateVectorSplat(VEC_LENGTH, loadAddr, "splat"+instName);
  //stick to the alignment of the original load
  vectorizedLDInstr = builder.CreateLoad(scalarToVector, "Ld"+instName);
  unsigned alignment = (dyn_cast<LoadInst> (pInst))->getAlignment();
  if (alignment >= 4) {
    vectorizedLDInstr->setAlignment(alignment);
  }
  instrInfo *pInstInfo = new instrInfo(vectorizedLDInstr);
  pInstInfo->setReplacedBy(vectorizedLDInstr);
  scalarToVectorMap[pInst] = pInstInfo;
  //pInst->eraseFromParent();
  errs() <<"vectorized load instruction: "<< *vectorizedLDInstr << "\n";
  //loadValue->replaceAllUsesWith(scalarToVector);   //FAIL: loadValue and scalarToVector are with different types
  return vectorizedLDInstr;
}*/

Instruction *Approx::duplicateScalarLoad(Instruction* pInst, const std::string &instName) {
  Value *loadValue = dyn_cast<Value> (pInst);
  //Instruction *operand = dyn_cast<Instruction>(loadValue);
  Instruction *vectorizedLDInstr = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);

  //if the current load value is not vectorized, we need to vectorize the value first
  if (!(loadValue->getType())->isVectorTy()) {
    Value *scalarToVector = builder.CreateVectorSplat(VEC_LENGTH, loadValue, "splat"+instName);
    vectorizedLDInstr = dyn_cast<Instruction> (scalarToVector);

    instrInfo *pInstInfo = new instrInfo(vectorizedLDInstr);
    pInstInfo->setReplacedBy(vectorizedLDInstr);
    scalarToVectorMap[pInst] = pInstInfo;
    //pInst->eraseFromParent();
    errs() <<"vectorized load instruction: "<< *vectorizedLDInstr << "\n";
    //loadValue->replaceAllUsesWith(scalarToVector);   //FAIL: loadValue and scalarToVector are with different types
  }

  return vectorizedLDInstr;
}

Instruction* Approx::duplicateScalarStore(Instruction *pInst, const std::string& instName) {
  Instruction *vecStInst = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);

  Value *oprand0 = pInst->getOperand(0);
  Value *stAddr = pInst->getOperand(1);    //address to store
  if (isa<Constant> (oprand0))
  {
    vecStInst = pInst->clone();
    vecStInst->insertBefore(insertAt);
  }
  else {
    Instruction *stVal = dyn_cast<Instruction> (oprand0);
    //errs() << " rrrrrrrrrrrrrrr " << *pInst->getOperand(0)->getType() << "      " << *stVal << "\n";
    Type* u32Ty = Type::getInt32Ty(currF->getContext());
    Value *index =  ConstantInt::get(u32Ty, 1);

    Value *extract = NULL;
    if (scalarToVectorMap.find(stVal) != scalarToVectorMap.end()) {
      Instruction *vecOp0 = scalarToVectorMap[stVal]->replacedBy();
      extract = builder.CreateExtractElement(vecOp0, index, "extract"+instName);
    }
    else {
      extract = stVal; 
    }

    vecStInst = builder.CreateAlignedStore(extract, stAddr, (dyn_cast<StoreInst> (pInst))->getAlignment());
  }

  instrInfo *pInstInfo = new instrInfo(vecStInst);
  pInstInfo->setReplacedBy(vecStInst);
  scalarToVectorMap[pInst] = pInstInfo;
  errs() << "New generated store instruction is: " << *vecStInst << "\n";

  return vecStInst;
}

Instruction* Approx::duplicateSelect(Instruction *pInst, const std::string& instName) {
  Instruction *vecSelect = NULL;
  Value *dupVal = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);
  //LLVMContext &ctxt = currF->getContext();
  //Type* u32Ty = Type::getInt32Ty(ctxt);
  //Value *index0 =  ConstantInt::get(u32Ty, 0);
  //Value *index1 =  ConstantInt::get(u32Ty, 1);

  Value *cond = pInst->getOperand(0);
  Instruction *condInst = dyn_cast<Instruction> (cond);
  //VectorType *condTy = VectorType::get(Type::getInt1Ty(ctxt), VEC_LENGTH);
  Value *condVec;

  if (scalarToVectorMap.find(condInst) != scalarToVectorMap.end()) {
    condVec = scalarToVectorMap[condInst]->replacedBy();    
  }
  //else if (Constant *CI = dyn_cast<Constant> (cond)) {
  //  condVec = dyn_cast<Value> (ConstantVector::getSplat(VEC_LENGTH, CI)); 
  //}
  else {
    //Value *emptyVec = UndefValue::get(condTy);
    //Value *val = builder.CreateInsertElement(emptyVec, cond, index0, "cond0"+instName);
    //condVec = builder.CreateInsertElement(val, cond, index1, "cond1"+instName);
    condVec = builder.CreateVectorSplat(VEC_LENGTH, cond, "splat"+instName);
  }

  Value *oprand1 = pInst->getOperand(1);
  Value *oprand2 = pInst->getOperand(2);
  Instruction *op1Inst = dyn_cast<Instruction> (oprand1);
  Instruction *op2Inst = dyn_cast<Instruction> (oprand2);
  //VectorType *valTy = VectorType::get(oprand1->getType(), VEC_LENGTH);
  //errs() << *oprand1 << "  " << *oprand2 <<"\n";

  Value *trueVec = NULL, *falseVec = NULL;
  if (scalarToVectorMap.find(op1Inst) != scalarToVectorMap.end()) {
    trueVec = scalarToVectorMap[op1Inst]->replacedBy();    
  }
  //else if (Constant *CI = dyn_cast<Constant> (oprand1)) {
  //  trueVec = dyn_cast<Value> (ConstantVector::getSplat(VEC_LENGTH, CI)); 
  //}
  else {
    //Value *emptyVec0 = UndefValue::get(valTy);
    //Value *val = builder.CreateInsertElement(emptyVec0, oprand1, index0, "ins0"+instName);
    //trueVec = builder.CreateInsertElement(val, oprand1, index1, "ins1"+instName);
    trueVec = builder.CreateVectorSplat(VEC_LENGTH, oprand1, "splat"+instName);
  }

  if (scalarToVectorMap.find(op2Inst) != scalarToVectorMap.end()) {
    falseVec = scalarToVectorMap[op2Inst]->replacedBy();    
  }
  //else if (Constant *CI = dyn_cast<Constant> (oprand2)) {
  //  falseVec = dyn_cast<Value> (ConstantVector::getSplat(VEC_LENGTH, CI)); 
  //}
  else {
    //Value *emptyVec1 = UndefValue::get(valTy);
    //Value *val = builder.CreateInsertElement(emptyVec1, oprand2, index0, "insVal10"+instName);
    //falseVec = builder.CreateInsertElement(val, oprand2, index1, "insVal11"+instName);
    falseVec = builder.CreateVectorSplat(VEC_LENGTH, oprand2, "spl"+instName);
  }

  std::string name = pInst->getName().str();
  dupVal = builder.CreateSelect(condVec, trueVec, falseVec, name+instName);
  vecSelect = dyn_cast<Instruction> (dupVal);
  instrInfo *pInstInfo = new instrInfo(vecSelect);
  pInstInfo->setReplacedBy(vecSelect);
  scalarToVectorMap[pInst] = pInstInfo;

  errs() << "vectorized select instruction is: " << *vecSelect << "\n";

  return vecSelect;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupOtherInst"
Instruction* Approx::duplicateBranch(Instruction *pInst, const std::string& instName) {
  Instruction *newBr = NULL;
  IRBuilder<> builder(&*pInst);
  LLVMContext &ctxt = currF->getContext();
  BranchInst *branch = dyn_cast<BranchInst> (pInst);

  if (branch->isUnconditional()) {  //no need to instrument unconditional branch
    return newBr;
  }
  
  Instruction *cond = dyn_cast<Instruction> (branch->getCondition());
  if (scalarToVectorMap.find(cond) == scalarToVectorMap.end()) { // the condition is constant or from other sources
    return newBr;
  } 
  Value *vecCond = scalarToVectorMap[cond]->replacedBy(); 

  Value *mask = builder.CreateBitCast(vecCond, Type::getIntNTy(ctxt, VEC_LENGTH), "BC"+instName);
  Value *constZero = ConstantInt::get(Type::getIntNTy(ctxt, VEC_LENGTH), 0);
  Value *oneBitMask = builder.CreateICmpNE(mask, constZero, "msk" + instName);

  (dyn_cast<BranchInst> (pInst))->setCondition(oneBitMask);
  return newBr;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupTruncExt"
// this function needs to be tested
Instruction* Approx::duplicateFPTruncExt(Instruction *pInst, const std::string& instName) {
  Instruction *dupInst = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);

  //errs() << " insert point is --------------------- " << *insertAt << "\n";

  Value *oprand = pInst->getOperand(0);
  Instruction *opInst = dyn_cast<Instruction> (oprand);

  VectorType *dstTy = VectorType::get(pInst->getType(), VEC_LENGTH);
  Value *src;
  Value *vecConvert;
  
  if (scalarToVectorMap.find(opInst) != scalarToVectorMap.end()) { //operand exists
    src = scalarToVectorMap[opInst]->replacedBy();    
  }
  //else if (Constant *CI = dyn_cast<Constant> (oprand)) {
  //  src = dyn_cast<Value> (ConstantVector::getSplat(VEC_LENGTH, CI)); 
  //}
  else {  // is constant or passed by caller 
    //VectorType *vecTy = VectorType::get(oprand->getType(), VEC_LENGTH);
    //Value *emptyVec = UndefValue::get(vecTy);
    //Type* u32Ty = Type::getInt32Ty(currF->getContext());
    //Value *index0 =  ConstantInt::get(u32Ty, 0);
    //Value *index1 =  ConstantInt::get(u32Ty, 1);
  
    //Value *val = builder.CreateInsertElement(emptyVec, oprand, index0, "ins0"+instName);
    //src = builder.CreateInsertElement(val, oprand, index1, "ins1"+instName);
    src = builder.CreateVectorSplat(VEC_LENGTH, oprand, "splat"+instName);
  }

  std::string name = pInst->getName().str();
  switch (pInst->getOpcode()) {
    case Instruction::FPExt:
      vecConvert = builder.CreateFPExt(src, dstTy, name+instName);
      break;
    case Instruction::FPTrunc:
      vecConvert = builder.CreateFPTrunc(src, dstTy, name+instName);
      break;
    case Instruction::Trunc:
      vecConvert = builder.CreateTrunc(src, dstTy, name+instName);
      break;
    case Instruction::ZExt:
      vecConvert = builder.CreateZExt(src, dstTy, name+instName);
      break;
    case Instruction::SExt:
      vecConvert = builder.CreateSExt(src, dstTy, name+instName);
      break;
  }

  dupInst = dyn_cast<Instruction> (vecConvert);

  instrInfo *pInstInfo = new instrInfo(dupInst);
  pInstInfo->setReplacedBy(dupInst);
  scalarToVectorMap[pInst] = pInstInfo;
      
  errs() << "Vectorized FPExtOrTrunc instruction is : " << *dupInst << "\n";

  return dupInst;
}

//vector the scalar integer to FP conversion instructions
Instruction* Approx::duplicateTypeConvert(Instruction *pInst, const std::string& instName) {
  Instruction *dupInst = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);
  errs() << " insert point is --------------------- " << *insertAt << "\n";

  Value *oprand = pInst->getOperand(0);
  std::string name = pInst->getName().str();
  Instruction *opInst = dyn_cast<Instruction> (oprand);
  Value *src;
  VectorType *dstTy = VectorType::get(pInst->getType(), VEC_LENGTH);
  Value *vecConvert;
  //Value *emptyVec;

  if (scalarToVectorMap.find(opInst) != scalarToVectorMap.end() && 
      scalarToVectorMap[opInst]->replacedBy() != NULL) {
    src = scalarToVectorMap[opInst]->replacedBy(); 
  //  errs() << "duplicated by : " <<*src << "\n";
  }
  //else if (Constant *CI = dyn_cast<Constant> (oprand)) {
  //  src = dyn_cast<Value> (ConstantVector::getSplat(VEC_LENGTH, CI)); 
  //}
  else {
    //VectorType *vecTy = VectorType::get(oprand->getType(), VEC_LENGTH);
    //emptyVec = UndefValue::get(vecTy);
    //Type* u32Ty = Type::getInt32Ty(currF->getContext());
    //Value *index0 = ConstantInt::get(u32Ty, 0);
    //Value *index1 = ConstantInt::get(u32Ty, 1);
  
    //Value *src0 = builder.CreateInsertElement(emptyVec, oprand, index0, "ins0"+instName);
    //src = builder.CreateInsertElement(src0, oprand, index1, "ins1"+instName);
    src = builder.CreateVectorSplat(VEC_LENGTH, oprand, "splat"+instName);
   // errs() << *dstTy << "      " << *src << "         " << *vecTy << "\n";
  }

  switch(pInst->getOpcode()) {
    case Instruction::UIToFP:
      vecConvert = builder.CreateUIToFP(src, dstTy, name+instName);
      break;
    case Instruction::SIToFP:
      vecConvert = builder.CreateSIToFP(src, dstTy, name+instName);
      break;
    case Instruction::FPToUI:
      vecConvert = builder.CreateFPToUI(src, dstTy, name+instName);
      break;
    case Instruction::FPToSI:
      vecConvert = builder.CreateFPToSI(src, dstTy, name+instName);
      break;
    case Instruction::IntToPtr:
      vecConvert = builder.CreateIntToPtr(src, dstTy, name+instName);
      break;
    case Instruction::PtrToInt:
      vecConvert = builder.CreatePtrToInt(src, dstTy, name+instName);
      break;
//    case Instruction::BitCast:
//      vecConvert = builder.CreateBitCast(src, dstTy, name+instName);
      break;
  }
  dupInst = dyn_cast<Instruction> (vecConvert);

  instrInfo *pInstInfo = new instrInfo(dupInst);
  pInstInfo->setReplacedBy(dupInst);
  scalarToVectorMap[pInst] = pInstInfo;
      
  errs() << "Vectorized int to FP: " << *dupInst << "\n";
 
  return dupInst;
}

//vectorize bitcast
//if one of the operands for bitcast instruction is a vector, we cannot vectorize it
Instruction* Approx::duplicateBitcast(Instruction *pInst, const std::string& instName) {
  Instruction *dupInst = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;
  IRBuilder<> builder(&*insertAt);

  Value *oprand = pInst->getOperand(0);
  
  if (oprand->getType()->isVectorTy() || pInst->getType()->isVectorTy()) {
    dupInst = pInst->clone();
    dupInst->setName(instName);
    dupInst->insertBefore(insertAt); 
    Value *bcVal = dyn_cast<Value>(pInst);
    Value *vBCVal = builder.CreateVectorSplat(VEC_LENGTH, bcVal, "splat"+instName);
    Instruction *bcInst = dyn_cast<Instruction> (vBCVal);
    instrInfo *pInstInfo = new instrInfo(bcInst);
    pInstInfo->setReplacedBy(bcInst);
    scalarToVectorMap[pInst] = pInstInfo;
  }
      
  errs() << "Vectorized bitcast : " << *dupInst << "\n";
  
  return dupInst;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupPhiNode"
//%phi1 = phi double [0.0, %if.then1] [1.0, %if.else2]
//%phi2 = phi double [1.0, %if.then2] [1.0, %if.else3]
//duplicate of %phi1
//duplicate of %phi2
//
Instruction* Approx::duplicatePhiNode(Instruction *pInst, const std::string &instName) {
  Instruction *dupInst = NULL;
  //IRBuilder<> builder(&*pInst);
  BasicBlock::iterator insertAt = pInst;

  //find a valid insert point for the duplicated instruction.
  //consider the situation where multiple phi nodes are sitting at the top of the current basic block.
  //we cannot insert the duplicate between phi nodes becase all phi nodes have to be grouped at the top
  //of the basic block.

  BasicBlock *pbb = pInst->getParent();

  //if the phi node is the first phi node, insert the duplicate value after the last phi node
  //otherwise, insert the current duplicate after the duplicate of the previous phi node
  if (&(pbb->front()) == pInst) {   //check if the phi node is the first node 
    while (insertAt->getOpcode() == Instruction::PHI)
      insertAt++;
  }
  else { 
    Instruction *lastInst = --insertAt;
    if (lastInst && pInst->getOpcode() == lastInst->getOpcode()) {
      insertAt = scalarToVectorMap[lastInst]->replacedBy();
    }
    else {
      insertAt++;
    }
    insertAt++;
  }
  
  //errs() << " insert point is --------------------- " << *insertAt << "\n";

  IRBuilder<> builder(&*insertAt);
  Value *phiNodeVal = dyn_cast<Value>(pInst);
  //Value *Val0 = builder.CreateInsertElement(emptyVec, phiNodeVal, index0, "ins0"+instName);
  //Value *Val1 = builder.CreateInsertElement(Val0, phiNodeVal, index1, "ins1"+instName);
  Value *Val1 = builder.CreateVectorSplat(VEC_LENGTH, phiNodeVal, "splat"+instName);
  //Instruction *InsertVal0 = dyn_cast<Instruction> (Val0);
  dupInst= dyn_cast<Instruction> (Val1);

  //InsertVal0->insertAfter(pInst);
  //vecPhiInst->insertAfter(InsertVal0);

  instrInfo *pInstInfo = new instrInfo(dupInst);
  pInstInfo->setReplacedBy(dupInst);
  scalarToVectorMap[pInst] = pInstInfo;
      
  errs() << "Vectorized phi node: " << *dupInst << "\n";
      
  return dupInst;
}

Instruction* Approx::duplicatePhiNodeVectorTy(Instruction *pInst, const std::string &instName) {
  Instruction *dupInst = NULL;

  if (scalarToVectorMap.find(pInst) != scalarToVectorMap.end()) {// this instruction has already been instrumented
    return dupInst;
  }

  BasicBlock::iterator insertAt = pInst;
  insertAt++; 
  IRBuilder<> builder(&*insertAt);
  //LLVMContext &ctxt = currF->getContext();

  PHINode *scalarPhi = dyn_cast<PHINode> (pInst);
  unsigned numIncomingValues = scalarPhi->getNumIncomingValues();
  Type  *retTy = VectorType::get(pInst->getType(), VEC_LENGTH);
  //PHINode *vectorPhi = builder.CreatePHI(retTy, numIncomingValues, "VPhi"+instName);
  PHINode *vectorPhi = builder.CreatePHI(retTy, 0, "VPhi"+instName);
  Value *valueToSet;
  bool tobeFixed = false;

  for (unsigned i = 0; i < numIncomingValues; i++) {
    Value *incomingVal = scalarPhi->getIncomingValue(i);
    errs() << "the value of the " << i << "th field of the PHI node is " << *incomingVal << "\n";
    BasicBlock *incomingBB = scalarPhi->getIncomingBlock(i);
    //if current value is a constant, we need to create a vector constant in the orginal bb
    //the reason why we cannot create the constant vector in the current bb is because we have
    //to keep phi nodes are grouped at the top of the current bb.
    Instruction *incomingInst = dyn_cast<Instruction> (incomingVal);
    if (scalarToVectorMap.find(incomingInst) != scalarToVectorMap.end()) {
      valueToSet = scalarToVectorMap[incomingInst]->replacedBy();
    }
    else {
      VectorType *vecTy = VectorType::get(incomingVal->getType(), VEC_LENGTH);
      Value *emptyVec = UndefValue::get(vecTy);
      
      if (Constant *CI = dyn_cast <Constant> (incomingVal)) {    //if the field is constant
        valueToSet = ConstantVector::getSplat(VEC_LENGTH, CI); 
      }
      else {        //if the current value is defined later or from other sources, e.g., caller, global
        valueToSet = emptyVec; 
        tobeFixed = true;
      }
    }
    //vectorPhi->setIncomingValue(i, valueToSet);
    //vectorPhi->setIncomingBlock(i, incomingBB);
    vectorPhi->addIncoming(valueToSet, incomingBB);
  }

  if (tobeFixed) { //if all value are constant or defined before usage, there is no need to deal with it
    tobeFixedPhiNodes.insert(pInst);
  }
  dupInst = dyn_cast<Instruction> (vectorPhi);
  instrInfo *pInstInfo = new instrInfo(dupInst);
  pInstInfo->setReplacedBy(dupInst);
  scalarToVectorMap[pInst] = pInstInfo;

  errs() << "The vectorized Phi node is " << *dupInst << "\n";
  return dupInst;
}

//there are probably holes in the phi nodes in the one pass scan because the use of some
//values in the phi nodes could be before the def of them. In this case, we cannot vectorize
//the use first, but only filling them with undefined values. In the second pass, we visit
//the phi nodes with holes and fix them.
bool Approx::fixHolesInPhiNodes() {
  bool success = true;
  for (std::set<Instruction*>::iterator it = tobeFixedPhiNodes.begin(), \
      end = tobeFixedPhiNodes.end(); it != end; it++ ) {
    PHINode *scalarPhi = dyn_cast<PHINode> (*it);
    PHINode *tobeFixed = dyn_cast<PHINode> (scalarToVectorMap[*it]->replacedBy());
    unsigned numIncomingValues = tobeFixed->getNumIncomingValues();
    for (unsigned i = 0; i < numIncomingValues; i++) {
      Value *vecIncomingVal = tobeFixed->getIncomingValue(i); 
      Value *scaIncomingVal = scalarPhi->getIncomingValue(i);
      Instruction *scalarInst = dyn_cast<Instruction> (scaIncomingVal);

      if (vecIncomingVal->getValueID() == Value::UndefValueVal) {  //the value needs to be fixed
        if (scalarToVectorMap.find(scalarInst) != scalarToVectorMap.end()) { // the inst is def after the phi node
          Value *realValue = scalarToVectorMap[scalarInst]->replacedBy();
          tobeFixed->setOperand(i, realValue);
        }
        else {
        //the value is from the other resource. This would be complicated since we need to insert the value for the 
        //phi node. To keep the phi node at the top of the current BB, we need to create a new BB for inserted values.
        
        }
      }
    }
  }
  return success;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupScalarArith"
Instruction *Approx::duplicateScalarArithmetic(Instruction *pInst, const std::string &chainPrefix, const int &numOperands) {
  Instruction *replacedInst = NULL;

  if (scalarToVectorMap.find(pInst) != scalarToVectorMap.end()) {
    replacedInst = scalarToVectorMap[pInst]->replacedBy(); 
    //errs() << " replacedReturn " << *replacedInst << "\n";
    return replacedInst;
  }

  Value *dupVal = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++; 
  LLVMContext &ctxt = currF->getContext();
  IRBuilder<> builder(&*insertAt);
  Value *oprnd = pInst->getOperand(0);
  Type *vecTy, *dstTy;
  if (oprnd->getType()->isVectorTy()) {
    vecTy = oprnd->getType();
  }
  else {
    vecTy = VectorType::get(oprnd->getType(), VEC_LENGTH);
  }

  if (pInst->getType()->isVectorTy()) {
    dstTy = pInst->getType();
  }
  else {
    dstTy = VectorType::get(pInst->getType(), VEC_LENGTH); 
  }

  Value *emptyVec = UndefValue::get(vecTy);
  Type* u32Ty = Type::getInt32Ty(ctxt);
  Value *index0 =  ConstantInt::get(u32Ty, 0);
  Value *index1 =  ConstantInt::get(u32Ty, 1);
   
  //Value *oprnd1 = pInst->getOperand(1);
  Instruction *InsertVal0 = NULL;
  Instruction *InsertVal1 = NULL;
   
  if (oprnd->getType()->isVectorTy()) {
    InsertVal1 = (dyn_cast<Instruction> (oprnd))->clone();
    InsertVal1->insertBefore(insertAt);
  }
  else {
    InsertVal0 = InsertElementInst::Create(emptyVec, oprnd, index0, "insert0" + chainPrefix, insertAt);
    InsertVal1 = InsertElementInst::Create(InsertVal0, oprnd, index1, "insert1" + chainPrefix, insertAt); 
  }
  //builder.CreateVectorSplat(VEC_LENGTH, oprnd, "splat" + chainPrefix);
  //errs() << "HERERERERERE " << *InsertVal1 << "         " << pInst->getOpcodeName(pInst->getOpcode()) << "    " << pInst->getNumOperands() <<"\n";
  
  std::string instName = pInst->getName().str() + chainPrefix;
  switch(pInst->getOpcode()) {
    case Instruction::FAdd:
      dupVal = builder.CreateFAdd(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::Add:
      dupVal = builder.CreateAdd(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::FSub:
      dupVal = builder.CreateFSub(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::Sub:
      dupVal = builder.CreateSub(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::FMul:
      dupVal = builder.CreateFMul(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::Mul:
      dupVal = builder.CreateMul(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::FDiv:
      dupVal = builder.CreateFDiv(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::UDiv:
      dupVal = builder.CreateUDiv(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::SDiv:
      dupVal = builder.CreateSDiv(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::FRem:
      dupVal = builder.CreateFRem(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::URem:
      dupVal = builder.CreateURem(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::SRem:
      dupVal = builder.CreateSRem(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::Shl:
      dupVal = builder.CreateShl(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::AShr:
      dupVal = builder.CreateAShr(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::LShr:
      dupVal = builder.CreateLShr(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::And:
      dupVal = builder.CreateAnd(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::Or:
      dupVal = builder.CreateOr(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::Xor:
      dupVal = builder.CreateXor(InsertVal1, InsertVal1, instName);
      break;
    case Instruction::FCmp: {
      dupVal = builder.CreateFCmp((dyn_cast<FCmpInst>(pInst))->getPredicate(), InsertVal1, InsertVal1, instName);
      break;
    }
    case Instruction::ICmp: {
      dupVal = builder.CreateICmp((dyn_cast<ICmpInst>(pInst))->getPredicate(), InsertVal1, InsertVal1, instName);
      break;
    }
    case Instruction::Call: {           // the implementation is too tedious, this could be improved by using a function and fucntionCall table
      Function *func = dyn_cast<CallInst>(pInst)->getCalledFunction();
      std::string funName = "call";

      if (func != NULL)
        funName = func->getName().str(); 

      std::string Name = "v"+ funName;
      Name += chainPrefix;
      if (numOperands == 1) {     //sqrt
        if (funName == "sqrt") {
          dupVal = CreateVFSqrt(builder, InsertVal1, Name);
        }
        else if (funName == "fabs") {
          dupVal = CreateVFabs(builder, InsertVal1, Name);
        }
        else if (funName == "sin") {
          dupVal = CreateVSin(builder, InsertVal1, Name);
        }
        else if (funName == "cos") {
          dupVal = CreateVCos(builder, InsertVal1, Name);
        }
        else if (funName == "floor") {
          dupVal = CreateVFloor(builder, InsertVal1, Name);
        }
        else if (funName == "exp") {
          dupVal = CreateVExp(builder, InsertVal1, Name);
        }
        else if (funName == "exp2") {
          dupVal = CreateVExp2(builder, InsertVal1, Name);
        }
        else if (funName == "log") {
          dupVal = CreateVLog(builder, InsertVal1, Name);
        }
        else if (funName == "log2") {
          dupVal = CreateVLog(builder, InsertVal1, Name, 2);
        }
        else if (funName == "log10") {
          dupVal = CreateVLog(builder, InsertVal1, Name, 10);
        }
        else {                              //more intrinsic functions to be added
          replacedInst = duplicateCall(pInst, instName);
          InsertVal1->eraseFromParent();
          InsertVal0->eraseFromParent();
          return replacedInst;
        }
      }
      else if (numOperands == 2) {
        if (funName == "pow" || funName == "powi") {
          dupVal = CreateVPow(builder, InsertVal1, InsertVal1, Name); //FIXME the second parameter should be <2 x int> for powi
        }
        else {
          InsertVal1->eraseFromParent();
          InsertVal0->eraseFromParent();
          return replacedInst;
        }
      }
      else if (numOperands == 3)  {
        if (funName == "fma") {
          dupVal = CreateVFma(builder, InsertVal1, InsertVal1, InsertVal1, Name); //FIXME the second parameter should be <2 x int> for powi
        }
        else {
          InsertVal1->eraseFromParent();
          InsertVal0->eraseFromParent();
          return replacedInst;
        }
      }
      else {
        //dupVal =InsertVal1;
        //replacedInst = dyn_cast<Instruction>(dupVal);
        //instrInfo *pInstInfotmp = new instrInfo(replacedInst);
        //pInstInfotmp->setReplacedBy(replacedInst);
        //scalarToVectorMap[pInst] = pInstInfotmp;
        //errs() << "Vertorized call: " << *replacedInst << "\n";
        InsertVal1->eraseFromParent();
        InsertVal0->eraseFromParent();
        return replacedInst;
      }
      break;
    }
    case Instruction::SIToFP:
    case Instruction::FPToSI:
    case Instruction::UIToFP:
    case Instruction::FPToUI:
    case Instruction::IntToPtr:
    case Instruction::PtrToInt: {
      //case Instruction::AddrSpaceCast:
      replacedInst = duplicateTypeConvert(pInst, instName);
      InsertVal1->eraseFromParent();
      InsertVal0->eraseFromParent();
      InsertVal1 = NULL; InsertVal0 = NULL;
      errs() << *replacedInst << "\n"; 
      return replacedInst;
    }
    case Instruction::BitCast: {
      Value *oprand = pInst->getOperand(0);
      if (oprand->getType()->isVectorTy() || pInst->getType()->isVectorTy()) {
        replacedInst = duplicateBitcast(pInst, instName);
        InsertVal1->eraseFromParent();
        InsertVal0->eraseFromParent();
        InsertVal1 = NULL; InsertVal0 = NULL;
        //errs() << *replacedInst << "\n"; 
        return replacedInst;
      }
      else {
        dupVal = builder.CreateBitCast(InsertVal1, dstTy, "bitcast"+instName);
      }
      break;
    }
    case Instruction::ExtractElement: {
      replacedInst = duplicateExtractElement(pInst, instName);
      InsertVal1->eraseFromParent();
      if (InsertVal0)
        InsertVal0->eraseFromParent();
      InsertVal1 = NULL; InsertVal0 = NULL;
      return replacedInst;
    }
    /*case Instruction::SIToFP:
      dupVal = builder.CreateSIToFP(InsertVal1, dstTy, "SIToFP"+instName);
      break; 
    case Instruction::UIToFP:
      dupVal = builder.CreateUIToFP(InsertVal1, dstTy, "UIToFP"+instName);
      break;*/
    case Instruction::FPTrunc:
    case Instruction::Trunc:
    case Instruction::FPExt:
    case Instruction::ZExt:
    case Instruction::SExt: {
      replacedInst = duplicateFPTruncExt(pInst, instName);
      InsertVal1->eraseFromParent();
      InsertVal0->eraseFromParent();
      InsertVal1 = NULL; InsertVal0 = NULL;
      errs() << *replacedInst << "\n"; 
      return replacedInst;
    }
    case Instruction::PHI: {
      //replacedInst = duplicatePhiNode(pInst, instName);
      replacedInst = duplicatePhiNodeVectorTy(pInst, instName);
      InsertVal1->eraseFromParent();
      InsertVal0->eraseFromParent();
      InsertVal1 = NULL; InsertVal0 = NULL;
      errs() << *replacedInst << "\n"; 
      return replacedInst;
    }
    case Instruction::Alloca: 
    case Instruction::GetElementPtr: {
      replacedInst = duplicateScalarGEP(pInst, instName);
      InsertVal1->eraseFromParent();
      InsertVal0->eraseFromParent();
      InsertVal1 = NULL; InsertVal0 = NULL;
      errs() << *replacedInst << "\n"; 
      return replacedInst;
    }
    case Instruction::Load: {
      replacedInst = duplicateScalarLoad(pInst, instName);
      InsertVal1->eraseFromParent();
      InsertVal0->eraseFromParent();
      InsertVal1 = NULL; InsertVal0 = NULL;
      errs() << *replacedInst << "\n"; 
      return replacedInst;
    }

    default:
      assert("Instruction is not supported!");
      break;
  } 

  //errs() << "ddddddddddddddddddddd " << *dupVal << "\n";

  replacedInst = dyn_cast<Instruction>(dupVal);
  instrInfo *pInstInfo = new instrInfo(replacedInst);
  pInstInfo->setReplacedBy(replacedInst);
  scalarToVectorMap[pInst] = pInstInfo;
  
  //iterate over operands
  int oprndCount = 0;
  for(User::op_iterator itr =  pInst->op_begin(), itr_e = pInst->op_end(); itr != itr_e; ++itr){
    if (numOperands > 0 && oprndCount >= numOperands)
      break;
    Value* usedVal = *itr;
    if (Constant *CI = dyn_cast<Constant>(usedVal)) {
      Constant *constVec = ConstantVector::getSplat(VEC_LENGTH, CI); 
      replacedInst->setOperand(oprndCount, constVec);
      errs() << "replaced instruction " << *replacedInst << "\n";
    }
    else if(Instruction *usedInstr = dyn_cast<Instruction>(usedVal)){   //the instruction is defined before
      DEBUG(dbgs() << "used Instruction " << *usedInstr << "\n");
      if(!breakRecDuplication(pInst, usedInstr)){
        //recursive call
        Instruction *dupUser = duplicateScalarArithmetic(usedInstr, chainPrefix);
        if(replacedInst && dupUser){
          //errs() << ",,,,,,,,,,,,,,,,, " << *replacedInst << "\n" << "................... " <<dupUser->getOpcodeName() << "    " << *dupUser << "\n";
          replacedInst->setOperand(oprndCount, dupUser);
          errs() << "replaced instruction " << *replacedInst << "\n";
        }
      }
    }
    else {    //the instructino is new, i.e., %mul = fmul double %f, 1.2 ;where %f is not generated in the current BB but passed from a caller
      insertAt = replacedInst;
      IRBuilder<> irbld(&*insertAt); 
      Value *Val1 = irbld.CreateVectorSplat(VEC_LENGTH, usedVal, "splat" + chainPrefix);
      replacedInst->setOperand(oprndCount, Val1); 
      errs() << "replacedInst" << *replacedInst << "\n";
    }
    oprndCount++;
  }
  if (InsertVal1 && InsertVal0) {
    InsertVal1->eraseFromParent();  //erase them in the reversed order. There would be an error if we erase insertVal0 first because InsertVal1 wants to use it
    InsertVal0->eraseFromParent();
  }
  duplicatedIR++;
  return replacedInst;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DupCall"
Instruction *Approx::duplicateCall(Instruction *pInst, const std::string& instName) {
  Instruction *dupInst = NULL;
  BasicBlock::iterator insertAt = pInst;
  insertAt++;

  //errs() << " insert point is --------------------- " << *insertAt << "\n";

  Value *vCall = dyn_cast<Value>(pInst);
   
  IRBuilder<> builder(&*insertAt);
  Value *Val1 = builder.CreateVectorSplat(VEC_LENGTH, vCall, "splat" + instName);

  //Instruction *InsertVal0 = dyn_cast<Instruction> (Val0);
  Instruction *vecPhiInst = dyn_cast<Instruction> (Val1);

  //errs() << "aaaaaaaaaaaaaaaaaa " << *InsertVal0 << "  " << *vecPhiInst << "\n";

  instrInfo *pInstInfo = new instrInfo(vecPhiInst);
  pInstInfo->setReplacedBy(vecPhiInst);
  scalarToVectorMap[pInst] = pInstInfo;
      
  errs() << "Vectorized call: " << *vecPhiInst << "\n";
      
  return dupInst;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"
//recursively duplicate producers until one of the following is
//encountered
// 1. instructions is safe
// 2. instructions is already duplicated
//
// Returns the duplicated instruction
#undef DEBUG_TYPE
#define DEBUG_TYPE "DupProducersRec"
Instruction* Approx::duplicateProdRec(Instruction *pInst, const std::string &chainPrefix){
  //clone and insert if not already duplicated && (if
  //the instruction is not safe || dupall option is given)
  //if(!instrToInfoObj[pInst]->isHighValue()){
  //check the instructions at: http://llvm.org/docs/doxygen/html/Instruction_8cpp_source.html
  Instruction* duplicatedInst = NULL;
  //FIXME
  if(instrToInfoObj[pInst]->isDuplicated()){
    duplicatedInst = instrToInfoObj[pInst]->duplicatedBy();
  }
  else{
    //if((!instrToInfoObj[pInst]->isStateVar())){
      bool breakAtFreqValue = false;
      if(breakAtFreqValue){
        //if we inserted a freq value comparision here then we don
        //t need to consider for further recursive duplication.
        DEBUG(dbgs() << "producer chain terminated. VP\n");
      }
      //duplicate load the address chain of a load and insert comparision
      else if(pInst->getOpcode() == Instruction::Load ||
	      pInst->getOpcode() == Instruction::Store ||
	      pInst->getOpcode() == Instruction::AtomicCmpXchg ||
	      pInst->getOpcode() == Instruction::Fence ||
	      pInst->getOpcode() == Instruction::GetElementPtr) {
        //duplicatedInst = pInst;
        DEBUG(dbgs() << "not duplicating memory instructions" << *pInst << "\n");
        /*
        Value* loadAddr = pInst->getOperand(0);
        if(Instruction* loadAddrInst = dyn_cast<Instruction>(loadAddr)){
          DEBUG(dbgs() << "address is " << *loadAddrInst << "\n");
          if(!breakRecDuplication(pInst, loadAddrInst)){
            if(!handledByValue(pInst)){
              Instruction* dupInst = duplicateProdRec(loadAddrInst, chainPrefix);
              insertCmp(pInst, dupInst, loadAddrInst, "LDCmp");
            }
            else{
              DEBUG(dbgs() << "Handled by value (exact or range)" << "\n");
            }
          }
        }
        */
      }
      else if (pInst->getOpcode() == Instruction::Alloca || 
               pInst->getOpcode() == Instruction::Call ||
               pInst->getOpcode() == Instruction::Switch ||
               pInst->getOpcode() == Instruction::Ret){	
        //do not duplicate alloca instruction, as this allocated memory
        //do not duplicate return instruction, 
        //do not duplicate call instruction, its operand would be taken
        //care of by HV inst
        DEBUG(dbgs() << "not duplicating alloca/call/ret: " << *pInst << "\n");
      }
      else if (//pInst->getOpcode() == Instruction::FCmp ||
	       //pInst->getOpcode() == Instruction::ICmp ||
	       pInst->getOpcode() == Instruction::PHI ||
               pInst->getOpcode() == Instruction::Br) {
	    DEBUG(dbgs() << "Cmp inst and Phi nodes will be handled later: " << *pInst << "\n");
      }
      else{
        //overhead of duplicated instructions.
        //if(RelUseProfile){
        //dynDupCount += PI->getExecutionCount(pInst->getParent());
        //annotateDuplicated(pInst);
        //}
        if(!handledByValue(pInst)){
          Instruction *dupInst = pInst->clone();
          dupInst->setName(chainPrefix);
          //LLVMContext &ctxt = currF->getContext();
          dupInst->insertBefore(pInst);
          instrToInfoObj[pInst]->setDuplicated(dupInst);
          duplicatedInst = dupInst;
          //DEBUG(dbgs() << "parent: " << dupInst->getParent() << "\n");

          //annotateDuplicate(dupInst);

          //iterate over operands
          unsigned oprndCount = 0;
          for(User::op_iterator itr =  pInst->op_begin(), itr_e = pInst->op_end(); itr != itr_e; ++itr){
            Value* usedVal = *itr;
            if(Instruction *usedInstr = dyn_cast<Instruction>(usedVal)){
                DEBUG(dbgs() << "used Instruction " << *usedInstr << "\n");
              if(!breakRecDuplication(pInst, usedInstr)){
                //recursive call
                Instruction* dupUser = duplicateProdRec(usedInstr, chainPrefix);
                if(duplicatedInst && dupUser){
                  duplicatedInst->setOperand(oprndCount, dupUser);
                }
              }
            }
            oprndCount++;
          }
          duplicatedIR++;
        }
        else{
//          duplicatedInst = pInst;
          DEBUG(dbgs() << "Handled by value (exact or range)" << "\n");
        }
      }
      //}
  }
  return duplicatedInst;
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

#undef DEBUG_TYPE
#define DEBUG_TYPE "DeleteScalar"
//delete is from the end to the begining to make sure that use is deleted before def
//the following code is implemented in a DFS way by traversing all the use-def chains
bool Approx::deleteInstrumentedScalarInst() {
  bool ret = true;

  LLVMContext &ctxt = currF->getContext();
  Type* u32Ty = Type::getInt32Ty(ctxt);
  Value *index =  ConstantInt::get(u32Ty, 0);
  BasicBlock::iterator tmp;
  Value *scalarPhiVal;
  //delete the instruction according to the use-def chain

  for (std::vector<Instruction*>::reverse_iterator it = instrVec.rbegin(), end = instrVec.rend(); it != end; ++it) {
    Instruction *deleteInst = *it;
    errs () << "?????????????????????????? " << *deleteInst << "\n";
    if (deleteInst && scalarToVectorMap.find(deleteInst) != scalarToVectorMap.end()) {
      Instruction *dupPhi = scalarToVectorMap[deleteInst]->replacedBy();
      Value *vecPhiVal = dyn_cast<Value> (dupPhi);
      tmp = dupPhi;
      if (deleteInst->getOpcode() != Instruction::PHI) {
        //traverse the def-use chain to delete
        //errs() << "The deleting instruction is " << *deleteInst << "\n";
        tmp++;
        //deleteInstrDFS(deleteInst);
      }
      else {
        //errs() << "current phi" << *deleteInst << "\n";
        while (tmp->getOpcode() == Instruction::PHI)
          tmp++;
      }
      IRBuilder<> builder(&*tmp);
      if (vecPhiVal->getType()->isVectorTy()) {
        scalarPhiVal = builder.CreateExtractElement(vecPhiVal, index, "ext"+deleteInst->getName());
        extractedInst.push_back(scalarPhiVal);
      }
      else {
        scalarPhiVal = vecPhiVal;
      }
      //deleteInst->replaceAllUsesWith(scalarPhiVal); //this is problematic because we can replace all uses
      myReplaceUsesOfWith(dyn_cast<Value>(deleteInst), dupPhi, scalarPhiVal);
      deleteInstrDFS(deleteInst);
    }
  }

  for (std::vector<Value*>::iterator vit = extractedInst.begin(); vit != extractedInst.end(); ++vit) {
    Value *val = *vit;
    if (val->getNumUses() == 0) {
      Instruction *removeExt = dyn_cast<Instruction> (val);
      removeExt->eraseFromParent();
    } 
  }
  errs() << "deletion is done" << "\n";
  return ret;
}

void Approx::deleteInstrDFS(Instruction *pInst) {

  if (pInst == NULL)
    return;

  Value *instVal = dyn_cast<Value> (pInst);
  if (instVal->getNumUses() == 0) { //this is the last instruction, it can be erased safely
    errs() << "deleting: " << *pInst << "\n";
    pInst->eraseFromParent();
    std::vector<Instruction*>::iterator it = find(instrVec.begin(), instrVec.end(), pInst);
    instrVec.erase(it);
    scalarToVectorMap.erase(pInst);
    return;  
  }

  LLVMContext &ctxt = currF->getContext();
  Type* u32Ty = Type::getInt32Ty(ctxt);
  Value *index =  ConstantInt::get(u32Ty, 0);

  for (Value::use_iterator useIt = pInst->use_begin(), e = pInst->use_end(); useIt != e; ++useIt) {
    errs() << "Use Instruction is: " << *dyn_cast<Instruction> (*useIt) << "\n";
  }
  Value::use_iterator useIt = pInst->use_begin(), e = pInst->use_end(), next;
  while (useIt != e) {
  //for (Value::use_iterator useIt = pInst->use_begin(); e = pInst->use_end(); useIt != e; ++useIt, ++i) {
    next = useIt;
    next++;
    Instruction *curInst = dyn_cast<Instruction> (*useIt);
    errs() << "current Instruction is: " << *pInst << "\n" << *curInst << "\n";
    if (curInst && scalarToVectorMap.find(curInst) != scalarToVectorMap.end()) {  //we only delete the instrumented instructions currently
      Instruction *dupPhi = scalarToVectorMap[curInst]->replacedBy();
      BasicBlock::iterator tmp = dupPhi;
      if (curInst->getOpcode() != Instruction::PHI) { 
        tmp++;
      }
      else {    
        //otherwise replace the use of phi node with the scalar value extracted from the corresponding vector reg.
        //FIXME. however this is buggy, a phi node might be used by a scalar call... %call = call @srand48(%phi)
        //or it is still removable if we extract the scalar operand of the call from its vector counterpart.
        //in this case, the phi node is not removable.
        while (tmp->getOpcode() == Instruction::PHI)
          tmp++;
      }
      IRBuilder<> builder(&*tmp);
      Value *vecPhiVal = dyn_cast<Value> (dupPhi);
      Value *scalarPhiVal;
      if (vecPhiVal->getType()->isVectorTy()) {
        scalarPhiVal = builder.CreateExtractElement(vecPhiVal, index, "ext"+curInst->getName());
        extractedInst.push_back(scalarPhiVal);
      }
      else {
        scalarPhiVal = vecPhiVal;
      }
      //deleteInst->replaceAllUsesWith(scalarPhiVal); //this is problematic because we can replace all uses
      myReplaceUsesOfWith(dyn_cast<Value>(curInst), dupPhi, scalarPhiVal);
      deleteInstrDFS(curInst);
      errs() << "current delete is done!!" << "\n"; 
    }
    useIt = next;
  } //end for
}

//don't replace the instruction, inst_i, if:
//it is used by an instruction, inst_j,  on the def-use chain of inst and
//inst_j is going to be used by the duplicate of inst_i
//for example, 
//%1 = bit <2xdouble> %2, %3
//%1_tmp = insertelement <2xdouble>, %1, i32 0
//%1_dup = shufflevector <2xdouble>, %1_tmp, ...
//if we replace %1_tmp with one element in 1_dup, it won't work because
//we are going to have a use before def
void Approx::myReplaceUsesOfWith(Value *oldVal, Instruction *dupInst, Value *newVal) {
  for (Value::use_iterator userIt = oldVal->use_begin(), e = oldVal->use_end(); userIt != e; ++userIt) {
    User *curUser = *userIt;
    Instruction *useInst = dyn_cast<Instruction> (curUser);
    Value *useVal = dyn_cast<Value> (useInst);
    bool replace = true;
    //check if dupInst is using useVal
    for (User::op_iterator uIt = dupInst->op_begin(); uIt != dupInst->op_end(); ++uIt) {
      if (dyn_cast<Value>(*uIt) == useVal) { //if it is used later, don't replace it
        replace = false;
        break;
      }
    }

    if (replace) {
      curUser->replaceUsesOfWith(oldVal, newVal);
    }
  }
}
#undef DEBUG_TYPE
#define DEBUG_TYPE "APPROX"

void Approx::insertCmp(Instruction* insertPt, Instruction* dupInst, Instruction* origInst, 
                        const std::string &instName, bool insertAfter){
  //if we duplicated the instruction
  //create a comparision between duplicated operand and original instruction.
  //e.g. 
  //
  //%2 = getelementptr inbounds [100 x i32]* %a, i64 0, i64 %1
  //store i32 0, i32* %2, align 4
  //===>
  //%HV3_ = getelementptr inbounds [100 x i32]* %a, i64 0, i64 %HV3_2
  //%2 = getelementptr inbounds [100 x i32]* %a, i64 0, i64 %1
  //<Comparision here>
  //store i32 0, i32* %2, align 4
  //for the mini example, %HV3_ is dupInst and origInst is %2
  //FIXME: Are we inserting duplicate comparisions???
  BasicBlock::iterator insertAt = insertPt;
  if(insertAfter)
    insertAt++;
  if(dupInst){
    Instruction* cmpInst = NULL;
    //adjust dynDupCount
    //we are inserting two extra (cmp and br) for every high value comparision.
    //dynDupCount += 2*(PI->getExecutionCount(origInst->getParent()));
    if((origInst->getType())->isIntOrIntVectorTy() || 
        (origInst->getType())->isPointerTy()){
      cmpInst = new ICmpInst(insertAt, ICmpInst::ICMP_NE, origInst, dupInst, instName); 
      errs() << "Integer comparison "<< *cmpInst<<"\n";
      cmpInstInserted.insert(cmpInst);
    }
    else if((origInst->getType())->isFPOrFPVectorTy()){
        cmpInst = new FCmpInst(insertAt, FCmpInst::FCMP_ONE, origInst, dupInst, instName); 
        errs() << "FP comparison here "<< *cmpInst << " number of operands: " << cmpInst->getNumOperands() << "\n";
        cmpInstInserted.insert(cmpInst);
    }
    else{
      errs() << "Warning: This type is not handled\n"; 
    }
  }  
}

// split the basic block inserted with a comparison instruction. All the instructions before the comparison
// instruction (including itself) stay in the old basic block. Every instruction starting after the inserted 
// comparision moves to the new basic block
// read the tutorial from llvm http://llvm.org/releases/2.6/docs/tutorial/JITTutorial2.html
void Approx::splitBBAndPointExitBlock(){
  for(std::set<Instruction*>::iterator I = cmpInstInserted.begin(), E = cmpInstInserted.end(); I != E; ++I){
    //if the RelBB option is given split the basic block to
    //use the result of cmp instruction to divert control flow
    //relExit BB.
    Instruction* cmpInst = *I;
    LLVMContext &ctxt = currF->getContext();
    std::vector<Type*> params;
    Type* voidTp = Type::getVoidTy(ctxt);
    Type* intTp = Type::getInt32Ty(ctxt);
    //FunctionType* ft = FunctionType::get(voidTp, params, false);
    BasicBlock::iterator splitIt = cmpInst;
    splitIt++;
    IRBuilder<> builder(&*splitIt);
    if(APDebug){
      params.push_back(Type::getInt1Ty(ctxt));
      PointerType* PointerTy_2 = PointerType::get(IntegerType::get(ctxt, 8), 0);
      params.push_back(PointerTy_2);
      params.push_back(intTp);
      params.push_back(intTp);
      FunctionType* ftD  = FunctionType::get(voidTp, params, false);
      Value* funcName = getOrCreateGlobalName(cmpInst->getParent());
      Value *constOne = ConstantInt::get(intTp, 1);
      Constant *exitFuncD = currF->getParent()->getOrInsertFunction("printRelExitMsgD", ftD);
      builder.CreateCall4((Value*)exitFuncD, cmpInst, funcName, constOne, constOne);
    }
    else if(APExitBB){
//      BasicBlock::iterator splitIt = cmpInst;
//      splitIt++;
//      errs() << *splitIt << " is the instruction after inserted comparison" << "\n";
      BasicBlock* oldBB = cmpInst->getParent();
      BasicBlock* newBB = SplitBlock(oldBB, splitIt, this);
      Instruction* termInst = oldBB->getTerminator();
      errs() << newBB->front() << " is the first instruction in the newly inserted comparison" << "\n";
      errs() << *newBB->getTerminator() << " is the terminator in new BB" << "\n";
      errs() << *cmpInst<< " inserted comparison" << "\n"; 
      // ----------------------- commented by zhi ---------------------------------- 
      // FIX ME: condBr is never used. It is nevered required since SplitBlock will call splitBasicblock which creates
      // a branch from the old BB to the new BB automatically. However, we still need to consider the circumenstance
// when an error is detected. In this case, we would like to branch to a new basic block (e.g. print the error
// and exit). This is what the createExitBB does essentially. In this case, we need to create a branch from the
// old BB to the relExitBB (error handling code).

      // if the conditional value is a vector type, e.g. <2 x i1>, we cannot create the branch instruction directly using 
      // branchinst::create, because it will fail during the type checking: 
      // getCondition()->getType()->isIntegerTy(1) && "May only branch on boolean predicates!
      // In this case, we have to combine the returned results in cmpInst to make it as an "i1" (bool) type.
      
      //errs() << "xxxxxxxxxxxxxxxxxxxxxx" << relExitBB->front() << "\n" << newBB->front() << "\n" << *cmpInst << "\n" << oldBB->front() << "\n";
      //errs() << " ....................." << *(cmpInst->getType()) << "\n";
      if (cmpInst->getType()->isVectorTy()) {
        //FIXME set the mask according to the return value of cmpInst<2 x double>, <4 x float>, <4 x double>.....
        Value *oprnd = cmpInst->getOperand(0);
        Instruction *operand = dyn_cast<Instruction>(oprnd);
        VectorType *vecTy = (VectorType *) operand->getType();
        //use number of elements and the width of each element in the vector type to determined if SSE/AVX is used for ps/pd
        unsigned numOfElem = vecTy->getNumElements();
        //unsigned eltBits = vecTy->getElementType()->getPrimitiveSizeInBits();
                        
        Value *mask = ConstantInt::get(Type::getIntNTy(ctxt, numOfElem), 0);
        BitCastInst *nbits = new BitCastInst(cmpInst, Type::getIntNTy(currF->getContext(), numOfElem), "", termInst);
        Instruction *tmp = new ICmpInst(termInst, ICmpInst::ICMP_NE, nbits, mask);
        BranchInst* condBr = BranchInst::Create(relExitBB, newBB, tmp, oldBB);
        errs() << "conditional branch: " << *condBr << "\n";
      }
      else {
        BranchInst* condBr = BranchInst::Create(relExitBB, newBB, cmpInst, oldBB);
        errs() << "conditional branch: " << *condBr << "number of operands: " << condBr->getNumOperands() << "\n";
        //remove the original uncond branch
      }
      termInst->eraseFromParent();
    }
  }      
  return;
}

//create an exit basic block
//this basic block would be transferred control if any of the checkers fail.
//this function could be modified to handle soft errors in the following way:
//1. Exit directly (this is what we are implementing in the following function.
//2. Increment the error count by 1
//3. Recovery
//4. .....
void Approx::createExitBB(){
  if(APExitBB){
    relExitBB = BasicBlock::Create(currF->getContext(), "relExit", currF);
    Value* retVal = NULL;
    //Constant* funcName = ConstantArray::get(F.getContext(), "myFunc");
    IRBuilder<> builder(relExitBB);
    //exitString << "Reliability CMP failed in function \%s" << currF->getNameStr() << "\n";
    if(!exitStr){
      std::stringstream exitString;
      exitString << "Reliability CMP failed in function, exit directly %s" << "\n";
      exitStr = builder.CreateGlobalStringPtr(exitString.str().c_str(), "relFun");
    }
    Value* funcName = getOrCreateGlobalName();

    std::vector<Type*> params;
    //const Type* ret_t; //FIXME: Never used
    FunctionType* ft;
    LLVMContext &ctxt = currF->getContext();
    Type* intTp = Type::getInt32Ty(ctxt);
    Type* voidTp = Type::getVoidTy(ctxt);
    Type* ptr8Type = Type::getInt8PtrTy(ctxt);
    Module *M = currF->getParent();

    //insert the printf call
    params.push_back(ptr8Type);
    ft  = FunctionType::get(intTp, params, true);
    Constant* printFun = M->getOrInsertFunction("printf", ft);
    builder.CreateCall2((Value*)printFun, exitStr, funcName);
    //insert the exit function
    params.clear();
    params.push_back(Type::getInt32Ty(currF->getContext()));
    ft  = FunctionType::get(voidTp, params, false);
    Value *constOne = ConstantInt::get(intTp, 1);
    Constant *exitFunc = M->getOrInsertFunction("exit", ft);
    //insert the exit function call
    builder.CreateCall((Value*)exitFunc, constOne);

    //This doesn't seem to be right way to do it: FIXME
    //What shoud be the terminator of block containing 
    //exit instruction?
    if(!(currF->getReturnType()->isVoidTy())){
      retVal = Constant::getNullValue(currF->getReturnType());
    }

    //ReturnInst* retInst = ReturnInst::Create(currF->getContext(), retVal, relExitBB);
    ReturnInst::Create(currF->getContext(), retVal, relExitBB);
  }
  return;
}

//added by zhi to handle errors
void Approx::createIncRetBB() {
    if(APExitBB){
	    relExitBB = BasicBlock::Create(currF->getContext(), "relExit", currF);
    	//Value* retVal = NULL;
    	//Constant* funcName = ConstantArray::get(F.getContext(), "myFunc");
    	IRBuilder<> builder(relExitBB);
        //exitString << "Reliability CMP failed in function \%s" << currF->getNameStr() << "\n";
   	    if(!exitStr){
    	    std::stringstream exitString;
            exitString << "Reliability CMP failed in function, increment the error count by 1 %s" << "\n";
            exitStr = builder.CreateGlobalStringPtr(exitString.str().c_str(), "relFun");
        }
        

    }
    return;
}

void Approx::createEDCECCBB() {
  return;
}

bool Approx::breakRecDuplication(Instruction* cInst, Instruction* opnd){
  bool retVal = false;
  return retVal;
}
Value* Approx::getOrCreateGlobalName(){                                                                                                                                                  
  if(FunctionToGlobalName.find(currF) != FunctionToGlobalName.end()){
    return FunctionToGlobalName[currF];
  }
  else{
    IRBuilder<> Builder(&currF->getEntryBlock());
    Value* bbName = Builder.CreateGlobalStringPtr(currF->getName(), "func");
    FunctionToGlobalName[currF] = bbName;
    return bbName;
  }
}

Value* Approx::getOrCreateGlobalName(BasicBlock* bb){
  if(BBToGlobalName.find(bb) != BBToGlobalName.end()){
    return BBToGlobalName[bb];
  }
  else{
    IRBuilder<> Builder(&currF->getEntryBlock());
    std::string name = bb->getParent()->getName().str() + "__" + bb->getName().str();
    Value* bbName = Builder.CreateGlobalStringPtr(name.c_str(), "func");
    BBToGlobalName[bb] = bbName;                                                                                                                                                              
    return bbName;
  }
}

bool Approx::handledByValue(Instruction* inst){
  bool isInValueSet = (valueCheckSet.find(inst) != valueCheckSet.end());
  bool isInValueRangeSet = (valueRangeCheckSet.find(inst) != valueRangeCheckSet.end());
  return (isInValueSet || isInValueRangeSet);
}

void Approx::createGlobal(){
  if(vpGlobal == NULL){
    Module *M = currF->getParent();
    GlobalVariable* sigVar = new GlobalVariable(*M,
               IntegerType::get(M->getContext(), 32),
               false,
               GlobalValue::ExternalLinkage,
               0,
               "gVPCount");
    ConstantInt* const_int32_8 = ConstantInt::get(M->getContext(), APInt(32, StringRef("0"), 10));
    sigVar->setInitializer(const_int32_8);
    vpGlobal = sigVar;
  }
}

int Approx::getSize(Type* ty){                                                                                                                                                             
  int i = TD->getTypeSizeInBits(ty);
  switch(i){
    case 1:
      return 1;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    default:
      errs() << "getSize:" << i << " this is not handled\n";
      return -1;
  }
}

#undef DEBUG_TYPE
#define DEBUG_TYPE "SQRT"
Value *Approx::CreateVFSqrt(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module* M = currF->getParent();

  //Value* sqrtv = Intrinsic::getDeclaration(M, Intrinsic::x86_sse2_sqrt_pd, tys);
  Value* sqrtv = Intrinsic::getDeclaration(M, Intrinsic::sqrt, tys);
  Value *CI = builder.CreateCall(sqrtv, v, Name); 
  
  return CI; 
}

Value *Approx::CreateVFabs(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module* M = currF->getParent();

  //Value* sqrtv = Intrinsic::getDeclaration(M, Intrinsic::x86_sse2_sqrt_pd, tys);
  Value* sqrtv = Intrinsic::getDeclaration(M, Intrinsic::fabs, tys);
  Value *CI = builder.CreateCall(sqrtv, v, Name); 
  
  return CI; 
}

Value *Approx::CreateVPow(IRBuilder<> &builder, Value *index, Value *exp, const std::string& Name) {
  SmallVector<Type*, 2> tys;    //two arguments
  tys.push_back(index->getType());
//  tys.push_back(exp->getType());
  Module *M = currF->getParent();

  Value *vpow;
  if (exp->getType()->isFPOrFPVectorTy())
    vpow = Intrinsic::getDeclaration(M, Intrinsic::pow, tys);
  else
    vpow = Intrinsic::getDeclaration(M, Intrinsic::powi, tys);

  Value *CI = builder.CreateCall2(vpow, index, exp, Name);

  return CI;
}

Value *Approx::CreateVExp(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vexp = Intrinsic::getDeclaration(M, Intrinsic::fabs, tys);
  Value *CI = builder.CreateCall(vexp, v, Name);
 
  return CI;
}

Value *Approx::CreateVExp2(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vexp2 = Intrinsic::getDeclaration(M, Intrinsic::fabs, tys);
  Value *CI = builder.CreateCall(vexp2, v, Name);
  
  return CI;
}

Value *Approx::CreateVSin(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vsqrt = Intrinsic::getDeclaration(M, Intrinsic::sin, tys);
  Value *CI = builder.CreateCall(vsqrt, v, Name);
  
  return CI;
}

Value *Approx::CreateVCos(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vsqrt = Intrinsic::getDeclaration(M, Intrinsic::cos, tys);
  Value *CI = builder.CreateCall(vsqrt, v, Name);
  
  return CI;
}

Value *Approx::CreateVFloor(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vfloor = Intrinsic::getDeclaration(M, Intrinsic::floor, tys);
  Value *CI = builder.CreateCall(vfloor, v, Name);
  
  return CI;
}

Value *Approx::CreateVCeil(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vceil = Intrinsic::getDeclaration(M, Intrinsic::ceil, tys);
  Value *CI = builder.CreateCall(vceil, v, Name);
  
  return CI;
}

/*Value *Approx::CreateVRound(IRBuilder<> &builder, Value *v, const std::string& Name) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vround = Intrinsic::getDeclaration(M, Intrinsic::round, tys);
  Value *CI = builder.CreateCall(vround, v, Name);
  //return builder.CreateRet(dyn_cast<Value> (CI));
  return CI;
}*/

Value *Approx::CreateVLog(IRBuilder<> &builder, Value *v, const std::string& Name, const int& index) {
  Type *tys[] = {v->getType()};
  Module *M = currF->getParent();

  Value *vlog;
  switch(index) {
    case 0:
      vlog = Intrinsic::getDeclaration(M, Intrinsic::log, tys);
    break;
    case 2:
      vlog = Intrinsic::getDeclaration(M, Intrinsic::log2, tys);
      break;
    case 10:
      vlog = Intrinsic::getDeclaration(M, Intrinsic::log10, tys);
      break;
  }
  Value *CI = builder.CreateCall(vlog, v, Name);
  
  return CI;
}

Value *Approx::CreateVFma(IRBuilder<> &builder, Value *a, Value *b, Value *c, const std::string& Name) {
  SmallVector<Type*, 3> tys;    //three arguments
  tys.push_back(a->getType());
  tys.push_back(b->getType());
  tys.push_back(c->getType());
  Module *M = currF->getParent();

  Value *vfma;
  vfma= Intrinsic::getDeclaration(M, Intrinsic::fma, tys);

  Value *CI = builder.CreateCall3(vfma, a, b, c, Name);
  
  return CI;
}

Value *Approx::CreateVMovmsk_pd(IRBuilder<> &builder, Value *v, const std::string& Name) {
  SmallVector<Type*, 1> tys;
  tys.push_back(v->getType());

  Module *M = currF->getParent();
  Value *vmovmsk = Intrinsic::getDeclaration(M, Intrinsic::x86_sse2_movmsk_pd, tys);
  Value *CI = builder.CreateCall(vmovmsk, v, Name);

  return CI;
}

Value *Approx::CreateVMovmsk_ps(IRBuilder<> &builder, Value *v, const std::string& Name) {
  SmallVector<Type*, 1> tys;
  tys.push_back(v->getType());

  Module *M = currF->getParent();
  Value *vmovmsk = Intrinsic::getDeclaration(M, Intrinsic::x86_sse_movmsk_ps, tys);
  Value *CI = builder.CreateCall(vmovmsk, v, Name);

  return CI;
}
#undef DEBUG_TYPE


